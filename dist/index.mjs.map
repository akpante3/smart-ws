{"version":3,"sources":["../src/core/EventEmitter.ts","../src/core/backoff.ts","../src/core/SmartSocket.ts","../src/index.ts"],"sourcesContent":["type Handler<T extends any[]> = (...args: T) => void;\n\nexport class EventEmitter<Events extends Record<string, any[]>> {\n  private listeners = new Map<keyof Events, Set<Handler<any>>>();\n\n  on<K extends keyof Events>(event: K, handler: Handler<Events[K]>): () => void {\n    let set = this.listeners.get(event);\n    if (!set) {\n      set = new Set();\n      this.listeners.set(event, set);\n    }\n    set.add(handler as Handler<any>);\n    return () => this.off(event, handler);\n  }\n\n  off<K extends keyof Events>(event: K, handler: Handler<Events[K]>): void {\n    const set = this.listeners.get(event);\n    if (!set) return;\n    set.delete(handler as Handler<any>);\n  }\n\n  emit<K extends keyof Events>(event: K, ...args: Events[K]): void {\n    const set = this.listeners.get(event);\n    if (!set) return;\n    for (const handler of set) {\n      handler(...args);\n    }\n  }\n\n  removeAllListeners() {\n    this.listeners.clear();\n  }\n}\n","import type { ReconnectOptions } from \"./types\";\n\nexport function createBackoff(opts: ReconnectOptions) {\n  const {\n    minDelay = 500,\n    maxDelay = 20_000,\n    factor = 2,\n    jitter = 0.2,\n  } = opts;\n\n  let attempt = 0;\n\n  function nextDelay() {\n    const exp = minDelay * Math.pow(factor, attempt);\n    const base = Math.min(exp, maxDelay);\n    const jitterAmount = base * jitter;\n    const random = (Math.random() * 2 - 1) * jitterAmount; // ±jitterAmount\n    attempt += 1;\n    return Math.max(0, base + random);\n  }\n\n  function reset() {\n    attempt = 0;\n  }\n\n  return { nextDelay, reset };\n}\n","import { EventEmitter } from \"./EventEmitter\";\nimport { createBackoff } from \"./backoff\";\nimport type {\n    SmartWsOptions,\n    SmartWsEvents,\n    SmartWsStatus,\n    ReconnectOptions,\n} from \"./types\";\n\nconst isBrowser = typeof window !== \"undefined\";\n\nexport class SmartSocket<TIn = any, TOut = any> {\n    private url: string;\n    private ws: WebSocket | null = null;\n    private options: SmartWsOptions<TIn, TOut>;\n    private emitter = new EventEmitter<SmartWsEvents<TIn, TOut>>();\n\n    private status: SmartWsStatus = \"idle\";\n    private retries = 0;\n    private backoff: ReturnType<typeof createBackoff>;\n    private buffer: TOut[] = [];\n\n    private heartbeatTimer: any = null;\n    private heartbeatTimeoutTimer: any = null;\n    private lastPing?: number;\n    private lastPong?: number;\n    private latencyMs?: number;\n    private closedManually = false;\n\n    constructor(url: string, options: SmartWsOptions<TIn, TOut> = {}) {\n        this.url = url;\n        this.options = options;\n        this.backoff = createBackoff(options.reconnect ?? {});\n        this.setupOnlineOfflineListeners();\n        this.connect();\n    }\n\n    getStatus(): SmartWsStatus {\n        return this.status;\n    }\n\n    getRetries(): number {\n        return this.retries;\n    }\n\n    getLatency(): number | undefined {\n        return this.latencyMs;\n    }\n\n    getLastPing(): number | undefined {\n        return this.lastPing;\n    }\n\n    getLastPong(): number | undefined {\n        return this.lastPong;\n    }\n\n    on = this.emitter.on.bind(this.emitter);\n    off = this.emitter.off.bind(this.emitter);\n\n    send(message: TOut) {\n        if (this.status === \"open\" && this.ws && this.ws.readyState === WebSocket.OPEN) {\n            this._sendNow(message);\n        } else if (this.options.buffer?.enabled !== false) {\n            this.bufferMessage(message);\n        }\n    }\n\n    connect() {\n        this.closedManually = false;\n        this.createWebSocket();\n    }\n\n    disconnect(code?: number, reason?: string) {\n        this.closedManually = true;\n        this.status = \"closing\";\n        this.clearHeartbeat();\n        if (this.ws) this.ws.close(code, reason);\n    }\n    private createWebSocket() {\n        if (!isBrowser && !this.options.createWebSocket) {\n            throw new Error(\"SmartSocket: in Node provide options.createWebSocket\");\n        }\n\n        this.status = this.status === \"idle\" ? \"connecting\" : \"reconnecting\";\n\n        const wsCtor =\n            (this.options.createWebSocket as any) ||\n            (isBrowser ? WebSocket : undefined);\n\n        if (!wsCtor) {\n            throw new Error(\"SmartSocket: no WebSocket constructor available\");\n        }\n\n        const ws: WebSocket = new wsCtor(this.url);\n        this.ws = ws;\n\n        ws.onopen = () => {\n            this.status = \"open\";\n            this.retries = 0;\n            this.backoff.reset();\n            this.emitter.emit(\"open\");\n            this.startHeartbeat();\n            this.flushBuffer();\n        };\n\n        ws.onmessage = (event) => {\n            const data = this.options.json\n                ? (JSON.parse(event.data) as TIn)\n                : (event.data as unknown as TIn);\n\n            // naive pong detection: assume server responds quickly\n            if (this.options.heartbeat?.enabled !== false && this.lastPing) {\n                const now = Date.now();\n                this.lastPong = now;\n                this.latencyMs = now - this.lastPing;\n                this.emitter.emit(\"pong\");\n            }\n\n            this.emitter.emit(\"message\", data);\n        };\n\n        ws.onerror = (event) => {\n            this.emitter.emit(\"error\", event);\n        };\n\n        ws.onclose = (event) => {\n            this.clearHeartbeat();\n            this.emitter.emit(\"close\", event);\n\n            if (this.closedManually) {\n                this.status = \"closed\";\n                return;\n            }\n\n            this.scheduleReconnect();\n        };\n    }\n\n    private _sendNow(message: TOut) {\n        if (!this.ws) return;\n        const payload = this.options.json ? JSON.stringify(message) : (message as any);\n        this.ws.send(payload);\n    }\n\n    private bufferMessage(message: TOut) {\n        const max = this.options.buffer?.max ?? 200;\n        const strategy = this.options.buffer?.dropStrategy ?? \"oldest\";\n        if (this.buffer.length >= max) {\n            if (strategy === \"oldest\") this.buffer.shift();\n            else return; // drop newest\n        }\n        this.buffer.push(message);\n        this.emitter.emit(\"bufferAdd\", message);\n    }\n\n    private flushBuffer() {\n        if (!this.buffer.length) return;\n        const toFlush = [...this.buffer];\n        this.buffer = [];\n        for (const msg of toFlush) this._sendNow(msg);\n        this.emitter.emit(\"bufferFlush\", toFlush);\n    }\n\n    private scheduleReconnect() {\n        const reconnectOpts: ReconnectOptions = this.options.reconnect ?? {};\n        const maxRetries = reconnectOpts.retries ?? Infinity;\n\n        if (this.retries >= maxRetries) {\n            this.status = \"closed\";\n            return;\n        }\n\n        this.retries += 1;\n        const delay = this.backoff.nextDelay();\n        this.emitter.emit(\"reconnect\", this.retries);\n\n        setTimeout(() => {\n            this.createWebSocket();\n        }, delay);\n    }\n\n    private startHeartbeat() {\n        const hb = this.options.heartbeat;\n        if (!hb || hb.enabled === false) return;\n\n        const interval = hb.interval ?? 25_000;\n        const timeout = hb.timeout ?? 5_000;\n        const pingMessage = hb.message as TOut | undefined;\n\n        this.clearHeartbeat();\n\n        this.heartbeatTimer = setInterval(() => {\n            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;\n\n            this.lastPing = Date.now();\n            this.emitter.emit(\"ping\");\n            if (pingMessage) this._sendNow(pingMessage);\n\n            if (this.heartbeatTimeoutTimer) {\n                clearTimeout(this.heartbeatTimeoutTimer);\n            }\n\n            this.heartbeatTimeoutTimer = setTimeout(() => {\n                // no pong detected in time → force close\n                this.ws?.close(4000, \"Heartbeat timeout\");\n            }, timeout);\n        }, interval);\n    }\n\n    private clearHeartbeat() {\n        if (this.heartbeatTimer) {\n            clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = null;\n        }\n        if (this.heartbeatTimeoutTimer) {\n            clearTimeout(this.heartbeatTimeoutTimer);\n            this.heartbeatTimeoutTimer = null;\n        }\n    }\n    private setupOnlineOfflineListeners() {\n        if (!isBrowser || typeof window.addEventListener !== \"function\") return;\n\n        window.addEventListener(\"online\", () => {\n            this.emitter.emit(\"online\");\n            if (this.status === \"closed\" || this.status === \"reconnecting\") {\n                this.connect();\n            }\n        });\n\n        window.addEventListener(\"offline\", () => {\n            this.emitter.emit(\"offline\");\n            if (this.ws) this.ws.close(4001, \"Offline\");\n        });\n    }\n}\n\n","import { SmartSocket } from \"./core/SmartSocket\";\n\nexport * from \"./core/types\";\nexport { SmartSocket } from \"./core/SmartSocket\";\nexport default SmartSocket\n;\n"],"mappings":"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","names":["_a"]}